# ReduxToolkit

## Terminologies

- slice -> slice where we divide our state.

  - For example, in a blog post, comment,etc are all slices.

  - All these are stored inside a global store

- extraReducers - You would use extraReducers when you are dealing with an action that you have already defined somewhere else. The most common examples are responding to a createAsyncThunk action and responding to an action from another slice

- synchronous nature -> However, the flow of Redux's state management tasks is completely synchronous: dispatching an action immediately generates the chain of calls to middleware and reducers to carry out the state transition

- A Redux store doesn't know anything about async logic. It only knows how to synchronously dispatch actions, update the state by calling the root reducer function, and notify the UI that something has changed. Any asynchronicity has to happen outside the store

# Why we can mutate state directly? In react we cant mutate state directly but here how?

ReduxToolkit uses immer.js. When we are mutating the state actually immer.js under the hood creating a new state for us. **This happens only inside createSlice**

# Customising Generated Action Creators or Defining A Structure of a payload automatically

Using **prepare** and **reducer** inside the reducers in the slice will do this for us.

```js
reducers: {
    postAdded: {
        reducer(state, action) {
        state.push(action.payload);
        },
        prepare(title, content) {
        return {
            payload: {
            id: nanoid(),
            title,
            content,
            },
        };
        },
    },
},
```

```js
// just call the dispatch function
postAdded(title, content);
// instead of postAdded({title,content})
```

- The above code is generating the payload for us.
- So when we dispatch our actions we dont have to concerned about the state structure.

# ReduxThunk with reduxtoolkit

## Terminologies

- thunk - The word "thunk" is a programming term that means "a piece of code that does some delayed work". Rather than execute some logic now, we can write a function body or code that can be used to perform the work later.
  
  - For Redux specifically, "thunks" are a pattern of writing functions with logic inside that can interact with a Redux store's dispatch and getState methods.

  - created using createAsyncThunk


## Performing Async Logic with Redux Thunk

- By default, Redux’s actions are dispatched synchronously, which is a problem for any non-trivial app that needs to communicate with an external API or perform side effects. Redux also allows for middleware that sits between an action being dispatched and the action reaching the reducers.

- Redux Thunk is a middleware that lets you call action creators that return a function instead of an action object. That function receives the store’s dispatch method, which is then used to dispatch regular synchronous actions inside the function’s body once the asynchronous operations have been completed.

## Using thunk guide

* create a thunk slice
* then check the cases and put some logic using extrareducers of createSlice and builder parameter of extra reducers and .addCase of builder
* dispatch the thunk whenever required

## dispatch().unwrap() -> Handling the promise 
* Thunks may return a value when dispatched. A common use case is to return a promise from the thunk, dispatch the thunk from a component, and then wait for the promise to resolve before doing additional work.

* The thunks generated by createAsyncThunk will always return a resolved promise with either the *fulfilled* action object or *rejected* action object inside, as appropriate.

* The calling logic may wish to treat these actions as if they were the original promise contents. The promise returned by the dispatched thunk has an unwrap property which can be called to extract the payload of a fulfilled action or to throw either the error or, if available, payload created by rejectWithValue from a rejected action:

```js 
// in the component

const onClick = () => {
  dispatch(fetchUserById(userId))
    .unwrap()
    .then((originalPromiseResult) => {
      // handle result here
    })
    .catch((rejectedValueOrSerializedError) => {
      // handle error here
    })
}
```

* Or with async/await syntax:
``` js
// in the component

const onClick = async () => {
  try {
    const originalPromiseResult = await dispatch(fetchUserById(userId)).unwrap()
    // handle result here
  } catch (rejectedValueOrSerializedError) {
    // handle error here
  }
}
```